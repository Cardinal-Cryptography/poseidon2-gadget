//! The Poseidon algebraic hash function.

use std::convert::TryInto;
use std::fmt;
use std::iter;
use std::marker::PhantomData;

use ff::FromUniformBytes;
use ff::PrimeField;
use halo2_proofs::arithmetic::Field;

pub(crate) mod fp;
pub(crate) mod fq;
pub(crate) mod grain;
pub(crate) mod matrix_full;
pub(crate) mod matrix_partial;
pub(crate) mod mds;

#[cfg(test)]
pub(crate) mod test_vectors;

mod p128pow5t3;

pub use p128pow5t3::P128Pow5T3;

use grain::SboxType;

/// The type used to hold permutation state.
pub(crate) type State<F, const T: usize> = [F; T];

/// The type used to hold sponge rate.
pub(crate) type SpongeRate<F, const RATE: usize> = [Option<F>; RATE];

/// The type used to hold the MDS matrix and its inverse.
pub type Mds<F, const T: usize> = [[F; T]; T];

/// A specification for a Poseidon permutation.
pub trait Spec<F: Field, const T: usize, const RATE: usize>: fmt::Debug {
    /// The number of preliminary rounds, which were introduced in Poseidon 2.
    fn pre_rounds() -> usize;

    /// The number of full rounds for this specification.
    ///
    /// This must be an even number.
    fn full_rounds() -> usize;

    /// The number of partial rounds for this specification.
    fn partial_rounds() -> usize;

    /// The S-box for this specification.
    fn sbox(val: F) -> F;

    /// Side-loaded index of the first correct and secure MDS that will be generated by
    /// the reference implementation.
    ///
    /// This is used by the default implementation of [`Spec::constants`]. If you are
    /// hard-coding the constants, you may leave this unimplemented.
    fn secure_mds() -> usize;

    /// Generates `(round_constants, mds, mds^-1)` corresponding to this specification.
    fn constants() -> (Vec<[F; T]>, Mds<F, T>, Mds<F, T>);
}

/// Generates `(round_constants, matrix_full, matrix_partial_m_1)` corresponding to this specification.
pub fn generate_constants<
    F: FromUniformBytes<64> + Ord,
    S: Spec<F, T, RATE>,
    const T: usize,
    const RATE: usize,
>() -> (Vec<[F; T]>, Mds<F, T>, Mds<F, T>) {
    let r_f = S::full_rounds();
    let r_p = S::partial_rounds();

    let mut grain = grain::Grain::new(SboxType::Pow, T as u16, r_f as u16, r_p as u16);

    // No round constants in preliminary rounds.
    let mut round_constants: Vec<_> = vec![[F::ZERO; T]; S::pre_rounds()];

    round_constants
        .extend((0..r_f / 2).map(|_| std::array::from_fn(|_| grain.next_field_element())));

    round_constants.extend((0..r_p).map(|_| {
        let mut rc_row = [F::ZERO; T];
        rc_row[0] = grain.next_field_element();
        rc_row
    }));

    round_constants
        .extend((0..r_f / 2).map(|_| std::array::from_fn(|_| grain.next_field_element())));

    let matrix_full = matrix_full::generate();
    let matrix_partial_m_1 = matrix_partial::generate_matrix_m_1();

    (round_constants, matrix_full, matrix_partial_m_1)
}

/// Runs the Poseidon permutation on the given state.
pub(crate) fn permute<F: Field, S: Spec<F, T, RATE>, const T: usize, const RATE: usize>(
    state: &mut State<F, T>,
    matrix_full: &Mds<F, T>,
    matrix_part: &Mds<F, T>,
    round_constants: &[[F; T]],
) {
    let r_pre = S::pre_rounds();
    let r_f = S::full_rounds() / 2;
    let r_p = S::partial_rounds();

    let apply_matrix_full = |state: &mut State<F, T>| {
        let mut new_state = [F::ZERO; T];
        // Matrix multiplication
        #[allow(clippy::needless_range_loop)]
        for i in 0..T {
            for j in 0..T {
                new_state[i] += matrix_full[i][j] * state[j];
            }
        }
        *state = new_state;
    };

    let apply_matrix_part = |state: &mut State<F, T>| {
        let mut new_state = [F::ZERO; T];
        // Matrix multiplication
        #[allow(clippy::needless_range_loop)]
        for i in 0..T {
            for j in 0..T {
                if i == j {
                    new_state[i] += (matrix_part[i][j] + F::ONE) * state[j];
                } else {
                    new_state[i] += matrix_part[i][j] * state[j];
                }
            }
        }
        *state = new_state;
    };

    let pre_round = |state: &mut State<F, T>, _: &[F; T]| {
        apply_matrix_full(state);
    };

    let full_round = |state: &mut State<F, T>, rcs: &[F; T]| {
        for (word, rc) in state.iter_mut().zip(rcs.iter()) {
            *word = S::sbox(*word + rc);
        }
        apply_matrix_full(state);
    };

    let part_round = |state: &mut State<F, T>, rcs: &[F; T]| {
        for (word, rc) in state.iter_mut().zip(rcs.iter()) {
            *word += rc;
        }
        // In a partial round, the S-box is only applied to the first state word.
        state[0] = S::sbox(state[0]);
        apply_matrix_part(state);
    };

    iter::empty()
        .chain(iter::repeat(&pre_round as &dyn Fn(&mut State<F, T>, &[F; T])).take(r_pre))
        .chain(iter::repeat(&full_round as &dyn Fn(&mut State<F, T>, &[F; T])).take(r_f))
        .chain(iter::repeat(&part_round as &dyn Fn(&mut State<F, T>, &[F; T])).take(r_p))
        .chain(iter::repeat(&full_round as &dyn Fn(&mut State<F, T>, &[F; T])).take(r_f))
        .zip(round_constants.iter())
        .fold(state, |state, (round, rcs)| {
            round(state, rcs);
            state
        });
}

fn poseidon_sponge<F: Field, S: Spec<F, T, RATE>, const T: usize, const RATE: usize>(
    state: &mut State<F, T>,
    input: Option<&Absorbing<F, RATE>>,
    matrix_full: &Mds<F, T>,
    matrix_part: &Mds<F, T>,
    round_constants: &[[F; T]],
) -> Squeezing<F, RATE> {
    if let Some(Absorbing(input)) = input {
        // `Iterator::zip` short-circuits when one iterator completes, so this will only
        // mutate the rate portion of the state.
        for (word, value) in state.iter_mut().zip(input.iter()) {
            *word += value.expect("poseidon_sponge is called with a padded input");
        }
    }

    permute::<F, S, T, RATE>(state, matrix_full, matrix_part, round_constants);

    let mut output = [None; RATE];
    for (word, value) in output.iter_mut().zip(state.iter()) {
        *word = Some(*value);
    }
    Squeezing(output)
}

mod private {
    pub trait SealedSpongeMode {}
    impl<F, const RATE: usize> SealedSpongeMode for super::Absorbing<F, RATE> {}
    impl<F, const RATE: usize> SealedSpongeMode for super::Squeezing<F, RATE> {}
}

/// The state of the `Sponge`.
pub trait SpongeMode: private::SealedSpongeMode {}

/// The absorbing state of the `Sponge`.
#[derive(Debug, Clone)]
pub struct Absorbing<F, const RATE: usize>(pub(crate) SpongeRate<F, RATE>);

/// The squeezing state of the `Sponge`.
#[derive(Debug)]
pub struct Squeezing<F, const RATE: usize>(pub(crate) SpongeRate<F, RATE>);

impl<F, const RATE: usize> SpongeMode for Absorbing<F, RATE> {}
impl<F, const RATE: usize> SpongeMode for Squeezing<F, RATE> {}

impl<F: fmt::Debug, const RATE: usize> Absorbing<F, RATE> {
    pub(crate) fn init_with(val: F) -> Self {
        Self(
            iter::once(Some(val))
                .chain((1..RATE).map(|_| None))
                .collect::<Vec<_>>()
                .try_into()
                .unwrap(),
        )
    }
}

#[derive(Clone)]
/// A Poseidon sponge.
pub(crate) struct Sponge<
    F: Field,
    S: Spec<F, T, RATE>,
    M: SpongeMode,
    const T: usize,
    const RATE: usize,
> {
    mode: M,
    state: State<F, T>,
    matrix_full: Mds<F, T>,
    matrix_part: Mds<F, T>,
    round_constants: Vec<[F; T]>,
    _marker: PhantomData<S>,
}

impl<F: Field, S: Spec<F, T, RATE>, const T: usize, const RATE: usize>
    Sponge<F, S, Absorbing<F, RATE>, T, RATE>
{
    /// Constructs a new sponge for the given Poseidon specification.
    pub(crate) fn new(initial_capacity_element: F) -> Self {
        let (round_constants, matrix_full, matrix_part) = S::constants();

        let mode = Absorbing([None; RATE]);
        let mut state = [F::ZERO; T];
        state[RATE] = initial_capacity_element;

        Sponge {
            mode,
            state,
            matrix_full,
            matrix_part,
            round_constants,
            _marker: PhantomData,
        }
    }

    /// Absorbs an element into the sponge.
    pub(crate) fn absorb(&mut self, value: F) {
        for entry in self.mode.0.iter_mut() {
            if entry.is_none() {
                *entry = Some(value);
                return;
            }
        }

        // We've already absorbed as many elements as we can
        let _ = poseidon_sponge::<F, S, T, RATE>(
            &mut self.state,
            Some(&self.mode),
            &self.matrix_full,
            &self.matrix_part,
            &self.round_constants,
        );
        self.mode = Absorbing::init_with(value);
    }

    /// Transitions the sponge into its squeezing state.
    pub(crate) fn finish_absorbing(mut self) -> Sponge<F, S, Squeezing<F, RATE>, T, RATE> {
        let mode = poseidon_sponge::<F, S, T, RATE>(
            &mut self.state,
            Some(&self.mode),
            &self.matrix_full,
            &self.matrix_part,
            &self.round_constants,
        );

        Sponge {
            mode,
            state: self.state,
            matrix_full: self.matrix_full,
            matrix_part: self.matrix_part,
            round_constants: self.round_constants,
            _marker: PhantomData,
        }
    }
}

impl<F: Field, S: Spec<F, T, RATE>, const T: usize, const RATE: usize>
    Sponge<F, S, Squeezing<F, RATE>, T, RATE>
{
    /// Squeezes an element from the sponge.
    pub(crate) fn squeeze(&mut self) -> F {
        loop {
            for entry in self.mode.0.iter_mut() {
                if let Some(e) = entry.take() {
                    return e;
                }
            }

            // We've already squeezed out all available elements
            self.mode = poseidon_sponge::<F, S, T, RATE>(
                &mut self.state,
                None,
                &self.matrix_full,
                &self.matrix_part,
                &self.round_constants,
            );
        }
    }
}

/// A domain in which a Poseidon hash function is being used.
pub trait Domain<F: Field, const RATE: usize> {
    /// Iterator that outputs padding field elements.
    type Padding: IntoIterator<Item = F>;

    /// The name of this domain, for debug formatting purposes.
    fn name() -> String;

    /// The initial capacity element, encoding this domain.
    fn initial_capacity_element() -> F;

    /// Returns the padding to be appended to the input.
    fn padding(input_len: usize) -> Self::Padding;
}

/// A Poseidon hash function used with constant input length.
///
/// Domain specified in [ePrint 2019/458 section 4.2](https://eprint.iacr.org/2019/458.pdf).
#[derive(Clone, Copy, Debug)]
pub struct ConstantLength<const L: usize>;

impl<F: PrimeField, const RATE: usize, const L: usize> Domain<F, RATE> for ConstantLength<L> {
    type Padding = iter::Take<iter::Repeat<F>>;

    fn name() -> String {
        format!("ConstantLength<{L}>")
    }

    fn initial_capacity_element() -> F {
        // Capacity value is $length \cdot 2^64 + (o-1)$ where o is the output length.
        // We hard-code an output length of 1.
        F::from_u128((L as u128) << 64)
    }

    fn padding(input_len: usize) -> Self::Padding {
        assert_eq!(input_len, L);
        // For constant-input-length hashing, we pad the input with zeroes to a multiple
        // of RATE. On its own this would not be sponge-compliant padding, but the
        // Poseidon authors encode the constant length into the capacity element, ensuring
        // that inputs of different lengths do not share the same permutation.
        let k = (L + RATE - 1) / RATE;
        iter::repeat(F::ZERO).take(k * RATE - L)
    }
}

#[derive(Clone)]
/// A Poseidon hash function, built around a sponge.
pub struct Hash<
    F: Field,
    S: Spec<F, T, RATE>,
    D: Domain<F, RATE>,
    const T: usize,
    const RATE: usize,
> {
    sponge: Sponge<F, S, Absorbing<F, RATE>, T, RATE>,
    _domain: PhantomData<D>,
}

impl<F: Field, S: Spec<F, T, RATE>, D: Domain<F, RATE>, const T: usize, const RATE: usize>
    fmt::Debug for Hash<F, S, D, T, RATE>
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Hash")
            .field("width", &T)
            .field("rate", &RATE)
            .field("R_F", &S::full_rounds())
            .field("R_P", &S::partial_rounds())
            .field("domain", &D::name())
            .finish()
    }
}

impl<F: Field, S: Spec<F, T, RATE>, D: Domain<F, RATE>, const T: usize, const RATE: usize>
    Hash<F, S, D, T, RATE>
{
    /// Initializes a new hasher.
    pub fn init() -> Self {
        Hash {
            sponge: Sponge::new(D::initial_capacity_element()),
            _domain: PhantomData,
        }
    }
}

impl<F: PrimeField, S: Spec<F, T, RATE>, const T: usize, const RATE: usize, const L: usize>
    Hash<F, S, ConstantLength<L>, T, RATE>
{
    /// Hashes the given input.
    pub fn hash(mut self, message: [F; L]) -> F {
        for value in message
            .into_iter()
            .chain(<ConstantLength<L> as Domain<F, RATE>>::padding(L))
        {
            self.sponge.absorb(value);
        }

        self.sponge.finish_absorbing().squeeze()
    }
}

#[cfg(test)]
mod tests {
    use ff::{Field, FromUniformBytes};

    use super::{generate_constants, permute, ConstantLength, Hash, Mds, Spec};
    use halo2curves::bn256::Fr;

    fn from_hex(a: &str) -> Fr {
        let mut a = hex::decode(a).unwrap();
        a.reverse();
        a.extend([0; 32]);
        let a: [u8; 64] = a.try_into().unwrap();
        Fr::from_uniform_bytes(&a)
    }

    #[derive(Copy, Clone, Debug)]
    pub enum Poseidon2Pow7TestSpec {}

    impl Spec<Fr, 8, 7> for Poseidon2Pow7TestSpec {
        fn pre_rounds() -> usize {
            1
        }

        fn full_rounds() -> usize {
            8
        }

        fn partial_rounds() -> usize {
            48
        }

        fn sbox(val: Fr) -> Fr {
            val.pow_vartime([7])
        }

        fn secure_mds() -> usize {
            0
        }

        fn constants() -> (Vec<[Fr; 8]>, Mds<Fr, 8>, Mds<Fr, 8>) {
            generate_constants::<Fr, Self, 8, 7>()
        }
    }

    #[test]
    fn poseidon2_pow7_permute() {
        let mut state: [Fr; 8] = Default::default();
        for (i, state_element) in state.iter_mut().enumerate() {
            *state_element = Fr::from(i as u64);
        }
        let (round_constants, matrix_full, matrix_partial) = Poseidon2Pow7TestSpec::constants();

        permute::<Fr, Poseidon2Pow7TestSpec, 8, 7>(
            &mut state,
            &matrix_full,
            &matrix_partial,
            &round_constants,
        );

        assert_eq!(
            state,
            [
                from_hex("25bd6b18db8af6d02b96e2d3ad9a0e8c0a3f8fc32a7b90ff5d558b650bdc6e14"),
                from_hex("1782f613fd4605f04abbf319e95a4bf7958a82a91adc48333f9e9f208178b824"),
                from_hex("064d3832f1ab6cb38c3dc851596597876a88d9b43e21635bf1ad53d9cfd2edb5"),
                from_hex("2cdfbf1065af6978aa5a44e1ba2ea31e53516229c7010144fbcb910d087dc379"),
                from_hex("0cb59531a220779f18c229dc3ebf2e1e617be83de30292ed418ef2a508d645d4"),
                from_hex("120eaca85e4c8e27e4effd1ea4c8d6c0c1ee86262d889086ece8294487ddc59e"),
                from_hex("19aa1e72638e9bd26c37708effa390d7e8dcfb6340cd818d2473fdab1cc5700d"),
                from_hex("09cfb67fc60f69d358bb2b8c3666bbbb46f4986f2aaa32c719b99254b7b243ac"),
            ]
        );
    }

    #[test]
    fn poseidon2_pow7_hash_1_element() {
        let sponge = Hash::<Fr, Poseidon2Pow7TestSpec, ConstantLength<1>, 8, 7>::init();

        let hash_result = sponge.hash([42].map(Fr::from));

        // First element of the permutation result for [42, 0, 0, 0, 0, 0, 0, (1 << 64)]
        // Last element of the initial state is the value of initial_capacity_element() for ConstantLength<1>.
        assert_eq!(
            hash_result,
            from_hex("25ef9eb9e686931547b65d4715e20ce1025096ce47bc583c8a0c04dffada82aa")
        );
    }

    #[test]
    fn poseidon2_pow7_hash_6_elements() {
        let sponge = Hash::<Fr, Poseidon2Pow7TestSpec, ConstantLength<6>, 8, 7>::init();

        let hash_result = sponge.hash([0, 1, 2, 3, 4, 5].map(Fr::from));

        // First element of the permutation result for [0, 1, 2, 3, 4, 5, 0, (6 << 64)]
        // Last element of the initial state is the value of initial_capacity_element() for ConstantLength<6>.
        assert_eq!(
            hash_result,
            from_hex("0ea4c4cfe25c8eb01181d76ee73f8405877984750ce196230c70a2fe8e643ae2")
        );
    }

    #[test]
    fn poseidon2_pow7_hash_7_elements() {
        let sponge = Hash::<Fr, Poseidon2Pow7TestSpec, ConstantLength<7>, 8, 7>::init();

        let hash_result = sponge.hash([0, 1, 2, 3, 4, 5, 6].map(Fr::from));

        // First element of the permutation result for [0, 1, 2, 3, 4, 5, 6, (7 << 64)]
        // Last element of the initial state is the value of initial_capacity_element() for ConstantLength<7>.
        assert_eq!(
            hash_result,
            from_hex("2b2dfc88c06b895f5504e0138f0efa1ed8c63c2f797c8443c2d66be12a50b63b")
        );
    }
}
